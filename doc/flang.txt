ВНИМАНИЕ! Данный файл устарел.

Стандарт языка FLANG

Оглавление
*Введение
*Запланированные возможности
*Описание языка
*Переменные
*Встроенные функции
*Библиотечные функции
*примеры кода


ВВЕДЕНИЕ

Язык FLANG, за свою всего двухлетнюю историю сменил несколько названий BFG(BrainFuck in Grids), BFAC(BF AutoCode), 
BFIL(Biargumental Functional Interpretive Language) и FAIL(Functional Asm-like Interpretive Language), и прошел долгий путь развития. 
На данном этапе, в версии 0.8.x реализовано около 70% функционала. Проект языка создан и реализован одним человеком. В данное время, 
исходные коды интерпретатора удалось собрать в Borland Delphi 7, FreePascal (x86\x64 Win и x86 *nix, а так же ARMv6), 
что позволяет назвать интерпретатор кроссплатформенным. 


ЗАПЛАНИРОВАННЫЕ ВОЗМОЖНОСТИ

Так как стандарт языка не завершен, и функционал всё ещё добавляется, было бы неосмотрительным не 
предупредить возможного пользователя о том, что некоторые особенности языка будут изменены или вовсе искоренены к финальной версии. 
Так же будет добавлен новый функционал, который сделает старые приёмы программирования на языке FLANG неэффективными. 

В финальной версии будут добавлены
0. Длинная арифметика.
1. Поддержка переменных, более 4кбайт длинной.
2. Эмуляция массивов и списков.
3. Валидатор кода и перехват ошибок времени исплнения.
4. Функции для работы со списками и массивами.

А так же много мелких исправлений, и самая любопытная опция - интерактивный режим.
В итоге, язык будет иметь все возможности для нормальной работы в текстовом режиме.


ОПИСАНИЕ ЯЗЫКА

Исходный код на языке FLANG представляет собой список команд, разделённых переводом строки. Отступы игнорируются. 
Комментарии доступны только однострочные, начинаются с символа # или с "//". В начале файла распологаются директивы "include" 
и описание функций. Далее распологается код программы, заключённый в операторные скобки "begin" и "end".


ПЕРЕМЕННЫЕ

Переменные могут быть объявлены в основной части кода или в функциях. Понятия "локальных переменных" отсутствует, 
все переменные видны из любой точки программы. Объявление переменной и присваивание значения происходит с помощью 
оператора "set <имя>, <значение>". Типизация переменных динамическая, неявная.

Доступ к переменным осуществляется с помощью квадратных скобок, конструкция [<имя переменной>] в качестве агрумента 
функции значит "вставить значение переменной".

Системные переменные, чьё значение устанавливается средой исполнения, доступны только к чтению, при попытки записи 
происходит ошибка.

Список системных переменных с описанием, формат <имя переменной> <тип значения> <описание>

1. _last (любой тип->string) - Содержит результат исполнения последней функции.
2. _inp (любой тип->string) - Вызывает ввод данных с клавиатуры? содержит введенную строку.


ВСТРОЕННЫЕ ФУНКЦИИ

Список встроенных функций с описанием, формат <имя функции> <количество аргументов> <возвр. значение> <описание>

1. return (1) (string) - Оператораня скобка для функции, определяет возвращаемое значение функции. Значение указывается как первый аргумент.
2. unset  (1) (null) - Освобождает место в памяти, занятое переменной. Имя переменной указывается как первый агрумент.
3. eq (2) (null) - Выполняет сравнение двух значений, и допускает исполнение следующей строки только в случае равенства значений.
4. neq (2) (null) - ..., допускает исполнение следующей строки только в случае неравенства значений.
5. less (2) (null) - ..., допускает исполнение следующей строки только в если первый аргумент меньше второго.
6. more (2) (null) - ..., допускает исполнение следующей строки только в если первый аргумент больше второго.
7. div (2) (integer или real) - Арифметическое деление, согласно типу.
8. end (0) (null) - Оператораня скобка, прекращает исполнение программы.
9. debug (1) (null) - Активирует режим отладки.
10. nop (1) (null) - Прерывает выполнение программы на указаное в первом аргументе кол-во миллесекунд.
11. out (2) (null) - Выводит на экран значение первого аргумента, с или без переноса в зависимости от значения второго аргумента.
12. set (2) (то же, что и в второго аргумента) - Создаёт(если не существовала) и присваивает значение переменной.
13. add (2) (integer или real) - Арифметическое сложение.
14. sub (2) (integer или real) - Арифметическое вычитание.
15. mul (2) (integer или real) - Арифметическое умножение.
16. mod (2) (integer) - Получение остатка от целочисленного деления.
17. conc (2) (string) - Соединение двух строк в одну.
18. len (1) (integer) - Получение длины строки в символах.
19. getc (2) (char как string) - Получение символа из строки, переданной в первом аргументе, номер символа - во втором.
20. jmp (1) (null) - Безусловный переход по адрксу или по метке.

Псевдо - функции
1. include (1) (null) - Вставляет содержимое другого файла за место комады include.
2. label (1) (null) - Объявляет метку с именем, указанном в первом операнде.
3. func (1) (null) - Объявляет функцию с именем, указанном в первом операнде.

БИБЛИОТЕЧНЫЕ ФУНКЦИИ

Библиотечные функции именуются по принципу <имя файла>:<имя функции>, например math:random или math:pow.
Функции внутри программы не требуют особых названий, вы вольны именовать их как вам вздумается. 

Описание функции начинается с оператора "func <имя функции>", и заканчивается оператором "return <переменная или 
константа>". Всё, что находится внутри, трактуется как код функции.

Каждая функция может иметь 2 аргумента, имеющие предопредопределенные имена "<имя функции>.x" и "<имя функции>.y", 
доступные как любые переменные.

Список встроенных функций с описанием, формат <имя файла>:<имя функции> <количество аргументов> <возвр. значение> <описание>

1. math:rand (1) (integer) - Возвращает псевдослучайное число, используя первый аргумент, как "зерно".
2. strutils:car (2) (string) - Возвращает часть строки, переданной в первом аргументе, от начала строки и до символа под номером, 
переданным во втором аргументе
3. strutils:car (2) (string) - Возвращает часть строки, переданной в первом аргументе, от символа под номером, переданным во 
втором аргументе, до конца строки.


ПРИМЕРЫ КОДА

# fLang 2013 (c) Ramiil Hetzer
# helloworld.src
# Простейшая программа

begin
 out "Hello, world", /n
end


# fLang 2013 (c) Ramiil Hetzer
# add_two.src
# Сложение двух чисел

begin
 out "Введите два числа", /n
 add [_inp], [_inp]
 out [_last], /n
end


# fLang 2013 (c) Ramiil Hetzer
# avergae.src
# Рассчёт средне-арифметического

begin
 out "Введите два числа", /n
 add [_inp], [_inp]
 set summ, [_last]
 div [summ], 2
 out [_last], /n
end


# fLang 2013 (c) Ramiil Hetzer
# func_test.src
# Использование функций

func test
 out "Это работает!",/n
 out test.x, /n
 out test.y, /n 
return 0

begin
 test "Первый аргумент", "Второй аргумент"
end


# fLang 2013 (c) Ramiil Hetzer
# lib_test.src
# Использование библиотечной функции

include lib/math.src

begin
 rand 10
 out [_last], /n
end